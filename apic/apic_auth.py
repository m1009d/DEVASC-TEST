#!/usr/bin/env python3

"""
APIC API requests require an authentication token.
The token can be generated by authenticating to the
/api/aaaLogin resource with username and password
using the POST request.

POST requests is the Create operation out of the CRUD operations.

Why we are using POST and not GET?
In order to get a token we need to send our username/password in the
HTTP message body. Despite the fact that any HTTP request message is
allowed to contain a message body, for GET, however, the body has no
semantic meaning to the request according to the HTTP/1.1 spec.
So we could send our username/password inside the HTTP GET request but
that message would be ignored. We need to use the HTTP POST instead as
stated in the APIC documentation.

An example of the body payload in JSON format looks like this:
{
    "aaaUser": {
        "attributes": {
            "name": "username",
            "pwd": "password"
        }
    }
}

You can also authenticate with the XML payload as follow:
<aaaUser name='admin' pwd='password'/>

After a successful request, the response will contain an authentication
token which can be used as a cookie to authenticate future requests.

APIC Sanbox can be found here:
https://sandboxapicdc.cisco.com/

ACI Programmability documentation:
https://developer.cisco.com/docs/aci/
"""

import sys
import json
import requests

# As we are working on a non-secured environment we can disable
# security warnings related to self-signed SSL certificate.
# Don't disable this in your production environment but rather
# configure your systems properly and secure.
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning
disable_warnings(InsecureRequestWarning)


def get_aci_token():
    """
    Function will authenticate to the Cisco sandbox APIC via the
    REST API and returns authentication token which will be used
    in future interacion with APIC API.
    """

    # APIC API URI - with JSON encoding
    APIC_URL = "https://sandboxapicdc.cisco.com/api/aaaLogin.json"

    # Storing passwords inside your scripts is not recommended but for the demo
    # purposes it is the easiest way.
    # One recommended way is to export your credentials as an environment variables
    # and then use these variables in your script.
    #
    # Example:
    # import os
    # PASSWORD = os.getenv('MY_SECURE_PASSWORD')
    #
    # Here the environment variable is called 'MY_SECURE_PASSWORD' which
    # contains your secret password.
    USERNAME = "admin"
    PASSWORD = "ciscopsdt"

    # Prepare the headers for the HTTP POST message
    headers = {
        'Content-Type': 'application/json',
        'Accept':       'application/json'
    }

    # Prepare the payload for the HTTP POST message
    # APIC API expects the JSON-Encoded data which means
    # we need to convert the payload dictionary into a
    # JSON string. To do this, we can use "json" argument
    # inside the requests.post() function or use the "data"
    # argument like this: requests.post(data=json.dumps(payload))
    payload = {
        "aaaUser": {
            "attributes": {
                "name": USERNAME,
                "pwd": PASSWORD
            }
        }
    }

    # Create the HTTP POST request
    # NOTE: verify=False is Not recommended TO USE in a production environment
    response = requests.post(
        url=APIC_URL,
        json=payload,   # or data=json.dumps(payload)
        headers=headers,
        verify=False
    )

    # Raise an exception if the response is not OK
    if not response.ok:
        print(json.dumps(response.json(), indent=4))
        response.raise_for_status()

    # Convert the response message into a JSON datastructure
    response_json = response.json()

    # Check if the token is present in the message
    try:
        token = response_json['imdata'][0]['aaaLogin']['attributes']['token']
    except KeyError:
        print('Token is not present in the response message!')
        # print the response and check manually where is the problem
        print(json.dumps(response_json, indent=4))
        # exit with error code 1
        sys.exit(1)

    return token
